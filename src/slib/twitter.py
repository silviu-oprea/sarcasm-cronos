import loggingimport requestsimport timeimport tweepyfrom lxml import htmlfrom slib import sitoolslogger = logging.getLogger('api.twitter')class ApiClientProvider:    def get_client(self, method, big_plans=False):        raise NotImplementedErrorclass FlaskApiClientProvider(ApiClientProvider):    def __init__(self, host='https://play.oprea.ch/social/twitter/api'):        self.link = '{}/getCredentials'.format(host)        self.conn_spec = None    def get_client(self, method, big_plans=False):        response = requests.get(self.link, {'method': method, 'big_plans': big_plans})        response.encoding = 'utf-8'        self.conn_spec = response.json()['connSpec']        auth_handler = tweepy.OAuthHandler(self.conn_spec['consumerKey'],                                           self.conn_spec['consumerSecret'])        auth_handler.set_access_token(self.conn_spec['accessToken'],                                      self.conn_spec['accessTokenSecret'])        api_client = tweepy.API(auth_handler)        return api_client    def __str__(self):        return str(self.conn_spec)def StatusesProvider(tids, api_client_provider):    api_client = api_client_provider.get_client(method='/statuses/lookup')    chunks = list(sitools.chunks(100, tids))    chunk_idx = 0    while True:        try:            if chunk_idx >= len(chunks):                raise StopIteration            wrapped_tweets = api_client.statuses_lookup(chunks[chunk_idx])            logger.info('[StatusesProvider] '                        'Got batch #{} / {}. Asked for 100 statuses, got {}'                        .format(chunk_idx + 1, len(chunks), len(wrapped_tweets)))            chunk_idx += 1            for wtweet in wrapped_tweets:                tweet = wtweet._json                tweet['user'] = {'id': tweet['user']['id'],                                 'id_str': tweet['user']['id_str'],                                 'screen_name': tweet['user']['screen_name']}                yield tweet        except tweepy.RateLimitError as e:            logger.warning('[StatusesProvider] {}, getting new api keys'.format(e))            api_client = api_client_provider.get_client(method='/statuses/lookup')        except tweepy.TweepError as e:            logger.info('[StatusesProvider] something with Tweepy went wrong, stopping: {}'                        .format(e))            raise StopIterationdef UserTimelineProvider(uid, api_client_provider, max_tid=None):    api_client = api_client_provider.get_client(method='/statuses/user_timeline')    while True:        try:            logger.info('[UserTimelineProvider] '                        'getting new batch of 200 tweets for uid {} with max_tid {}'                        .format(uid, max_tid))            timeline = api_client.user_timeline(user_id=uid, max_id=max_tid, count=200)            timeline = sorted([t._json for t in timeline], key=lambda t: t['id'],                              reverse=True)            if len(timeline) == 0:                raise StopIteration            max_tid = timeline[-1]['id'] - 1            for tweet in timeline:                tweet['user'] = {'id': tweet['user']['id'],                                 'id_str': tweet['user']['id_str'],                                 'screen_name': tweet['user']['screen_name']}                yield tweet        except tweepy.RateLimitError as e:            logger.warning('[UserTimelineProvider] {}, getting new api keys'.format(e))            api_client = api_client_provider.get_client(method='/statuses/user_timeline')        except tweepy.TweepError as e:            logger.info('[UserTimelineProvider] something went wrong, stopping: {}'                        .format(e))            raise StopIterationdef RetweetersProvider(tid, api_client_provider):    api_client = api_client_provider.get_client(method='/statuses/retweeters/ids')    while True:        try:            for uid in api_client.retweeters(id=tid, count=100):                yield uid            break        except tweepy.RateLimitError as e:            api_client = api_client_provider.get_client(method='/statuses/retweeters/ids')            logger.info('[RetweetersProvider] {}, trying again with credentials {}'                        .format(e, api_client_provider))        except Exception as e:            breakdef LikersProvider(handle, tid):    link = 'https://twitter.com/{}/status/{}'.format(handle, tid)    page = requests.get(link)    tree = html.fromstring(page.content)    atags = tree.xpath('//li[contains(@class, "js-face-pile-container")]/a')    for atag in atags:        yield int(atag.get('data-user-id'))def UserProvider(uspecs,                 api_client_provider=FlaskApiClientProvider(),                 lookup_by='uid'):    assert lookup_by in ['uid', 'handle'], 'lookup_by should be on of [uid, handle]'    api_client = api_client_provider.get_client(method='/users/lookup')    chunks = list(sitools.chunks(100, uspecs))    chunk_idx = 0    while True:        try:            if chunk_idx >= len(chunks):                raise StopIteration            if lookup_by == 'uid':                users = api_client.lookup_users(user_ids=chunks[chunk_idx])            else:                users = api_client.lookup_users(screen_names=chunks[chunk_idx])            for user in users:                yield user._json            chunk_idx += 1        except tweepy.RateLimitError as e:            logger.warning('[UserProvider] {}, getting new api keys'.format(e))            api_client = api_client_provider.get_client(method='/users/lookup')        except tweepy.TweepError as e:            logger.info('[UserProvider] something with Tweepy went wrong, stopping: {}'                        .format(e))            raise StopIteration